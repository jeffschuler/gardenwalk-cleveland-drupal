<?php

/**
 * @file
 * Provide a GeoJSON Views feed style.
 */

/**
 * Implements hook_views_api().
 */
function views_geojson_views_api() {
  return array(
    'api' => '2.0',
    'path' => drupal_get_path('module', 'views_geojson') . '/views',
  );
}

/**
 * We almost duplicate the content_handler_field_multiple::render function
 * to get the multiple rendered field values in an array
 * @param $field
 * @param $values
 * @return unknown_type
 */
function _views_geojson_render_multiple_field($field, $values) {
    $options = $field->options;
    // If this is not a grouped field, use content_handler_field::render().
    if (!$field->defer_query) {
      return $field->render($values);
    }
    // We're down to a single node here, so we can retrieve the actual field
    // definition for the node type being considered.
    $content_field = content_fields($field->content_field['field_name'], $values->{$field->aliases['type']});
    $vid = $values->{$field->field_alias};
    if (isset($field->field_values[$vid])) {
      // Gather items, respecting the 'Display n values starting from m' settings.
      $count_skipped = 0;
      $items = array();
      foreach ($field->field_values[$vid] as $item) {
        if (empty($options['multiple']['multiple_from']) || ($count_skipped >= $options['multiple']['multiple_from'])) {
          if (empty($options['multiple']['multiple_number']) || (count($items) < $options['multiple']['multiple_number'])) {
            // Grab the nid - needed for render_link().
            $nid = $item['_nid'];
            unset($item['_nid']);
            $items[] = $item;
          }
          else {
            break;
          }
        }
        $count_skipped++;
      }

      // Build a pseudo-node from the retrieved values.
      $node = drupal_clone($values);
      // content_format and formatters will need a 'type'.
      $node->type = $values->{$field->aliases['type']};
      $node->nid = $values->{$field->aliases['nid']};
      $node->vid = $values->{$field->aliases['vid']};

      // Some formatters need to behave differently depending on the build_mode
      // (for instance: preview), so we provide one.
      $node->build_mode = NODE_BUILD_NORMAL;

      // Render items.
      $formatter_name = $options['format'];
      if ($items && ($formatter = _content_get_formatter($formatter_name, $content_field['type']))) {
        $rendered = array();
        if (content_handle('formatter', 'multiple values', $formatter) == CONTENT_HANDLE_CORE) {
          // Single-value formatter.
          $n = 0;
          foreach ($items as $item) {
            $output = content_format($content_field, $item, $formatter_name, $node);
            if (!empty($output)) {
              $rendered[++$n] = $field->render_link($output, (object) array('nid' => $nid));
            }
          }
        }
        else {
          // Multiple values formatter.
          $output = content_format($content_field, $items, $formatter_name, $values);
          if (!empty($output)) {
            $rendered[++$n] = $field->render_link($output, (object) array('nid' => $nid));
          }
        }
        if (count($rendered) > 1) {
          // TODO: could we use generic field display ?
          //return theme('content_view_multiple_field', $rendered, $content_field, $values);
          return $rendered;
        }
        elseif ($rendered) {
          return $rendered[1];
        }
      }
    }

    return '';
}

/**
 * Takes each field from a row object and renders the field as determined by the field's theme.
 *
 * @param $view
 *    View the row belongs to
 * @param $row
 *   Row object
 * @return array
 *   Object containing all the raw and rendered fields
 */
function _views_geojson_render_fields($view, $row) {
  $excluded_fields = array();
  $feature = array();
  $rendered_record = array();

  $data_source = $view->style_plugin->options['data_source'];

  $field_ids = array_keys($view->field);
  $rendered_fields = array();
  foreach ($field_ids as $id) {
    $field = $view->field[$id];
    $field_is_multiple = FALSE;
    $field_raw = array();
    if ((isset($field->options['multiple']['group'])) && isset($field->field_values)) {
      $field_output = _views_json_render_multiple_field($field, $row);
      $n = 0;
      if (is_array($field_output)) {
        foreach ($field->field_values[$row->{$field->field_alias}] as $item) {
          $field_raw[++$n] = $item["value"];
        }
        $field_is_multiple = TRUE;
      }
      else {
        $field_raw = $view->field[$field->options['id']]->advanced_render($row);
        $rendered_record[$field->field_alias] = $field_raw;
      }
    }
    else {
      $field_output = $view->field[$field->options['id']]->advanced_render($row);
      $field_raw = (isset($view->field[$id]->field_alias) && isset($row->{$view->field[$id]->field_alias})) ? $row->{$view->field[$id]->field_alias} : NULL;
      $rendered_record[$field->field_alias] = $field_output;
    }

    if (empty($field->options['exclude']) && !empty($field_output)) {
      $object = new stdClass();
      $object->id = $id;
      $object->content = $field_output;
      $object->raw = $field_raw;
      $object->class = drupal_clean_css_identifier(drupal_strtolower($id));//views_css_safe($id);
      $object->label = check_plain($view->field[$id]->label());
      $object->is_multiple = $field_is_multiple;
      $rendered_fields[$id] = $object;
    }
  }

  // points with Latitude & Longitude
  if (!empty($data_source['value']['other_latlon'])) {
    $lat_field = $rendered_fields[$data_source['other_lat']];
    $lon_field = $rendered_fields[$data_source['other_lon']];
    $lon = floatval($lon_field->raw);
    $lat = floatval($lat_field->raw);
    if (!empty($lat) && !empty($lon)) {
      $feature['geometry'] =
        array(
          'type' => 'Point',
          'coordinates' => array($lon, $lat));
    }
    $excluded_fields[] = $lat_field;
    $excluded_fields[] = $lon_field;
  }
  // Bounding Box
  elseif ($data_source['value']['other_boundingbox']) {
    list($top_field, $right_field,
        $left_field, $bottom_field) = $this_->get_bounds($fields, $data_source);
    $top =    floatval($row->$top_field);
    $right =  floatval($row->$right_field);
    $left =   floatval($row->$left_field);
    $bottom = floatval($row->$bottom_field);
    if (!empty($top) && !empty($left)) {
      $feature['geometry'] =
        array(
          'type' => 'Polygon',
          'coordinates' => array(
            array($left, $top),
            array($right, $top),
            array($right, $bottom),
            array($left, $bottom))
          );
    }
    array_push($excluded_fields, $top_field, $right_field,
      $left_field, $bottom_field);
  }

  // Add the name and description attributes
  // as choosen through interface
  $name_field = NULL;
  if ($data_source['name_field']) {
    $name_field = $rendered_fields[$data_source['name_field']]->id;
    $feature['properties']['name'] = $rendered_fields[$name_field]->content;
    $excluded_fields[] = $name_field;
  }
  else {
    $feature['properties']['name'] = '';
  }

  $description_field = NULL;
  if ($data_source['description_field']) {
    $description_field = $rendered_fields[$data_source['description_field']]->id;
    $feature['properties']['description'] = $rendered_fields[$description_field]->content;
    $excluded_fields[] = $description_field;
  }
  else {
    $feature['properties']['description'] = '';
  }

  // Only add features with WKT data
  if (empty($feature['geometry'])) {
    return;
  }

  // Fill in attributes that are not:
  // - Coordinate/bounding box fields
  // - Name/description (already processed)
  // - Views "excluded" fields
  foreach ($field_ids as $id) {
    $field = $view->field[$id];
    $field_alias = $field->field_alias;
    if (!in_array($field_alias, $excluded_fields, TRUE)) {
      // Use regular field name as this is easier to understand
      $feature['properties'][$field_alias] = is_numeric($rendered_fields[$name_field]->raw) ?
        floatval($rendered_fields[$name_field]->raw) :
        $rendered_fields[$name_field]->raw;
      $feature['properties'][$field_alias . "_rendered"] = is_numeric($rendered_fields[$name_field]->content) ?
        floatval($rendered_fields[$name_field]->content) :
        $rendered_fields[$name_field]->content;
    }
  }

  return $feature;
}

/**
 * Render a view's output as JSON.
 *
 * The function will directly output a JSON string instead of returning it.
 *
 * @param $items
 *   The collection of items to encode into JSON.
 * @param $options
 *   Render options.
 */

/**
 * Encodes GeoJSON in a pretty-printed fashion.
 */
function _views_geojson_encode_formatted($v, $depth = 0) {
  $base_indent  = '&nbsp;&nbsp;';
  $eol          = '<br />';
  $indent       = str_repeat($base_indent, $depth);

  // This is based on the drupal_to_js() function.
  switch (gettype($v)) {
    case 'boolean':
      // Lowercase is necessary!
      return $v ? 'true' : 'false';

    case 'integer':
    case 'double':
      return $v;

    case 'resource':
    case 'string':
      $search   = array('"', chr(92), chr(8), chr(12), chr(13) . chr(10), chr(10), chr(13), chr(9));
      $replace  = array('\"', '\\', '\b', '\f', '\n', '\n', '\r', '\t');
      $output   = str_replace($search, $replace, $v);
/* *
      $output = str_replace(array("\r", "\n", "<", ">", "&"),
                           array('\r', '\n', '\x3c', '\x3e', '\x26'),
                           addslashes($output));
/* */
      return '"' . check_plain($output) . '"';

    case 'array':
      // Arrays in JSON can't be associative.  If the array is empty or if it
      // has sequential whole number keys starting with 0, it's not associative
      // so we can go ahead and convert it as an array.
      if (empty($v) || array_keys($v) === range(0, sizeof($v) - 1)) {
        $output = array();
        foreach ($v as $val) {
          $output[] = $indent . $base_indent . _views_geojson_encode_formatted($val, $depth + 1);
        }
        return '[' . (!empty($output) ? $eol . implode(',' . $eol, $output) . $eol . $indent : '') . ']';
      }
      // Otherwise, fall through to convert the array as an object.

    case 'object':
      $output = array();
      foreach ($v as $key => $val) {
        $output[] = $indent . $base_indent . _views_geojson_encode_formatted(strval($key)) . ' : ' . _views_geojson_encode_formatted($val, $depth + 1);
      }
      return '{' . (!empty($output) ? $eol . implode(',' . $eol, $output) . $eol . $indent : '') . '}';

    default:
      return 'null';
  }
}